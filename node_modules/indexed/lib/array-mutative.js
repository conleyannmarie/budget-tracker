'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.concat = concat;
exports.clear = clear;
exports.filter = filter;
exports.forEach = forEach;
exports.transform = transform;
exports.pop = pop;
exports.push = push;
exports.reverse = reverse;
exports.shift = shift;
exports.slice = slice;
exports.sort = sort;
exports.splice = splice;
exports.unshift = unshift;
exports.setItemByIndex = setItemByIndex;
exports.setItemWhere = setItemWhere;
exports.setMultipleItemsByIndex = setMultipleItemsByIndex;
exports.setMany = setMany;
exports.removeMany = removeMany;
exports.set = set;
exports.replace = replace;
exports.remove = remove;
exports.findMany = findMany;
exports.fromJson = fromJson;

var _arrayIndexes = require('./array-indexes');

var _utils = require('./utils');

var _constants = require('./constants');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function concat(props, arr) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	for (var _len = arguments.length, values = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
		values[_key - 2] = arguments[_key];
	}

	var length = values.length;var i = 0;var index = arr.length;
	var newArr = mutate ? arr : (0, _utils.slice)(arr);
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.cloneIndexes)(indexes) : null;
	props.lastIndexes = [];
	if (!length) {
		return [newIndexes, newArr];
	}
	while (i < length) {
		var value = values[i++];
		if ((0, _utils.isArrayLike)(value)) {
			var valueLength = value.length,
			    j = 0;
			while (j < valueLength) {
				var subValue = value[j++];
				(0, _arrayIndexes.setIndexes)(newIndexes, subValue, index);
				props.lastIndexes.push(index);
				newArr[index++] = subValue;
			}
		} else {
			(0, _arrayIndexes.setIndexes)(newIndexes, value, index);
			props.lastIndexes.push(index);
			newArr[index++] = value;
		}
	}
	return [newIndexes, newArr];
}

function clear(props, arr) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var newArr;
	var newIndexes = indexes ? (0, _arrayIndexes.copyIndexes)(indexes) : null;
	if (mutate) {
		newArr = _constants.arrProto.splice.call(0, arr.length);
	} else {
		newArr = [];
	}
	return [newIndexes, newArr];
}

function filter(props, arr, callback, thisArg) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var newArr = _constants.arrProto.filter.call(arr, callback, thisArg);
	var newIndexes = indexes ? (0, _arrayIndexes.copyIndexes)(indexes) : null;
	(0, _arrayIndexes.reindex)(newIndexes, newArr);
	return [newIndexes, newArr];
}
function forEach(props, arr, callback, thisArg) {
	var indexes = props.indexes;
	var mutate = props.mutate;
	var length = arr.length;var i = 0;
	while (i < length) {
		var val = arr[i];
		var result = callback.call(thisArg, val, i, arr);
		if (result === _constants.BREAK) {
			return;
		}
		i++;
	}
	return [indexes, arr];
}
function transform(props, arr, callback, thisArg) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	props.lastIndexes = [];
	var length = arr.length;var i = 0;var newArr = mutate ? arr : new Array(length);
	while (i < length) {
		var val = arr[i];
		var result = callback.call(thisArg, val, i, arr);
		if (result === _constants.BREAK) {
			break;
		}
		if (result === _constants.SKIP) {
			result = false;
		}
		props.lastIndexes.push(i);
		newArr[i] = result;
		i++;
	}
	newArr = _constants.arrProto.filter.call(newArr, Boolean);
	var newIndexes = indexes ? (0, _arrayIndexes.copyIndexes)(indexes) : null;
	(0, _arrayIndexes.reindex)(newIndexes, newArr);
	return [newIndexes, newArr];
}
function pop(props, arr, receiver) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var newArr = mutate ? arr : (0, _utils.slice)(arr);
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.cloneIndexes)(indexes) : null;
	var popped = newArr.pop();
	if (receiver) {
		receiver[0] = popped;
	}
	(0, _arrayIndexes.removeIndexes)(newIndexes, popped);
	return [newIndexes, newArr];
}
function push(props, arr) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	props.lastIndexes = [];

	for (var _len2 = arguments.length, values = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
		values[_key2 - 2] = arguments[_key2];
	}

	var length = values.length;var i = 0;var index = arr.length;
	var newArr = mutate ? arr : (0, _utils.slice)(arr);
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.cloneIndexes)(indexes) : null;
	if (!length) {
		return [newIndexes, newArr];
	}
	var max = i + length;
	while (i < length) {
		var value = values[i++];
		(0, _arrayIndexes.setIndexes)(newIndexes, value, index);
		props.lastIndexes.push(index);
		newArr[index++] = value;
	}
	return [newIndexes, newArr];
}
function reverse(props, arr) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var newArr = mutate ? arr : (0, _utils.slice)(arr);
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.cloneIndexes)(indexes) : null;
	newArr.reverse();
	(0, _arrayIndexes.reindex)(newIndexes, newArr);
	return [newIndexes, newArr];
}
function shift(props, arr, receiver) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var newArr = mutate ? arr : (0, _utils.slice)(arr);
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.cloneIndexes)(indexes) : null;
	var shifted = newArr.shift();
	if (receiver) {
		receiver[0] = shifted;
	}
	if (newIndexes) {
		(0, _arrayIndexes.removeIndexes)(newIndexes, shifted);
		(0, _arrayIndexes.shiftIndexes)(newIndexes, -1);
	}
	return [newIndexes, newArr];
}
function slice(props, arr, begin, end) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var newArr = (0, _utils.slice)(arr, begin, end);
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.cloneIndexes)(indexes) : null;
	var length = newArr.length;var i = 0;
	if (length != arr.length) {
		newIndexes = (0, _arrayIndexes.reindex)(newIndexes, newArr);
	}
	return [newIndexes, newArr];
}
function sort(props, arr, compareFunction) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var newArr = mutate ? arr : (0, _utils.slice)(arr);
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.copyIndexes)(indexes) : null;
	if (!compareFunction || typeof compareFunction == 'function') {
		newArr.sort(compareFunction);
	} else {
		var prop = compareFunction;
		newArr.sort(function (a, b) {
			return prop in a && prop in b ? a[prop] > b[prop] ? 1 : a[prop] < b[prop] ? -1 : 0 : 0;
		});
	}
	(0, _arrayIndexes.reindex)(newIndexes, newArr);
	return [newIndexes, newArr];
}

function fillArrayFrom(length, start) {
	return Array.apply(null, Array(length)).map(function (el, i) {
		return start + i;
	});
}

function splice(props, arr, start, deleteCount) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var newArr;
	deleteCount = deleteCount || 0;
	props.lastIndexes = [];

	for (var _len3 = arguments.length, items = Array(_len3 > 4 ? _len3 - 4 : 0), _key3 = 4; _key3 < _len3; _key3++) {
		items[_key3 - 4] = arguments[_key3];
	}

	if (mutate) {
		var _arrProto$splice;

		newArr = arr;
		(_arrProto$splice = _constants.arrProto.splice).call.apply(_arrProto$splice, [newArr, start, deleteCount].concat(items));
	} else {
		var head = (0, _utils.slice)(arr, 0, start);
		var tail = (0, _utils.slice)(arr, start + deleteCount);
		newArr = [].concat(head, items, tail);
	}
	if (items.length) {
		props.lastIndexes = fillArrayFrom(items.length, start);
	}
	var newIndexes = indexes ? (0, _arrayIndexes.copyIndexes)(indexes) : null;
	(0, _arrayIndexes.reindex)(newIndexes, newArr);
	return [newIndexes, newArr];
}
function unshift(props, arr) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	for (var _len4 = arguments.length, values = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
		values[_key4 - 2] = arguments[_key4];
	}

	var length = values.length;var i = 0;
	props.lastIndexes = [];
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.cloneIndexes)(indexes) : null;
	var newArr;
	if (!length) {
		return [newIndexes, newArr];
	}
	if (newIndexes) {
		(0, _arrayIndexes.shiftIndexes)(newIndexes, length);
		while (i < length) {
			var value = values[i];
			(0, _arrayIndexes.setIndexes)(newIndexes, value, i++);
		}
	}
	if (mutate) {
		_constants.arrProto.unshift.apply(arr, values);
		newArr = arr;
	} else {
		newArr = [].concat(values, arr);
	}
	props.lastIndexes = fillArrayFrom(values.length, 0);
	return [newIndexes, newArr];
}

function setItemByIndex(props, arr, index, value, replace, remove) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	if (typeof index == 'undefined' || index === null) {
		index = arr.length;
	}
	if (index < 0) {
		index = arr.length + index;
	}
	if (index >= arr.length) {
		return push(props, arr, value);
	}
	var newArr;
	var oldObj = arr[index];
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.cloneIndexes)(indexes) : null;
	if (remove) {
		if (mutate) {
			_constants.arrProto.splice.call(arr, index, 1);
			newArr = arr;
		} else {
			newArr = (0, _utils.slice)(arr, 0, index).concat((0, _utils.slice)(arr, index + 1));
		}
		(0, _arrayIndexes.reindex)(newIndexes, newArr);
	} else {
		newArr = mutate ? arr : (0, _utils.slice)(arr);
		if (replace) {
			newArr[index] = value;
			(0, _arrayIndexes.removeIndexes)(newIndexes, oldObj);
			(0, _arrayIndexes.setIndexes)(newIndexes, value, index);
		} else {
			(0, _arrayIndexes.changeIndexes)(newIndexes, oldObj, value, index);
			newArr[index] = (0, _utils.assign)(oldObj, value);
		}
		props.lastIndexes = [index];
	}
	return [newIndexes, newArr];
}

function setItemWhere(props, arr, predicate, value, replace, remove) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var index = (0, _arrayIndexes.findIndex)(props, arr, predicate);
	props.lastIndexes = [];
	if (index < 0) {
		return [indexes, arr];
	}
	return setItemByIndex(props, arr, index, value, replace, remove);
}

function setMultipleItemsByIndex(props, arr, indexesList, value, remove) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var newArr = mutate ? arr : (0, _utils.slice)(arr);
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.cloneIndexes)(indexes) : null;
	var length = indexesList.length;

	var i = 0;
	props.lastIndexes = [];
	if (!length) {
		return [newIndexes, newArr];
	}
	var newProps = { indexes: newIndexes, mutate: true, lastIndexes: props.lastIndexes };
	while (i < length) {
		var index = indexesList[i++];
		setItemByIndex(newProps, newArr, index, value, false, remove);
	}
	props.lastIndexes = newProps.lastIndexes;
	return [newIndexes, newArr];
}

function setMany(props, arr, predicates, value) {
	var indexesList = (0, _arrayIndexes.findIndexes)(props, arr, predicates);
	return setMultipleItemsByIndex(props, arr, indexesList, value);
}

function removeMany(props, arr, predicates, value) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var indexesList = (0, _arrayIndexes.findIndexes)(props, arr, predicates);
	var newArr = mutate ? arr : (0, _utils.slice)(arr);
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.cloneIndexes)(indexes) : null;
	var length = indexesList.length;

	var i = 0;
	var n = 0;
	if (!length) {
		return [newIndexes, newArr];
	}
	while (i < length) {
		var index = indexesList[i++] + n;
		if (mutate) {
			_constants.arrProto.splice.call(newArr, index, 1);
		} else {
			newArr = (0, _utils.slice)(newArr, 0, index).concat((0, _utils.slice)(newArr, index + 1));
		}
		n--;
	}
	(0, _arrayIndexes.reindex)(newIndexes, newArr);
	return [newIndexes, newArr];
}

function set(props, arr, indexOrPredicate, value, replace, remove) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	props.lastIndexes = [];
	if (indexOrPredicate !== null && typeof indexOrPredicate !== 'undefined') {
		if (typeof indexOrPredicate == 'number') {
			return setItemByIndex(props, arr, indexOrPredicate, value, replace, remove);
		}
		if (indexes) {
			return setItemWhere(props, arr, indexOrPredicate, value, replace, remove);
		}
	}
	if (replace || remove) {
		throw new Error('replace or remove invoked without a valid index');
	}
	return push(props, arr, value);
}

function replace(props, arr, indexOrPredicate, value) {
	return set(props, arr, indexOrPredicate, value, true, false);
}

function remove(props, arr, indexOrPredicate) {
	return set(props, arr, indexOrPredicate, null, false, true);
}

function findMany(props, arr, predicates, thisArg) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	var newArr = [];
	var newIndexes = indexes ? mutate ? indexes : (0, _arrayIndexes.copyIndexes)(indexes) : null;
	var indexesList = (0, _arrayIndexes.findIndexes)(props, arr, predicates, thisArg);
	if (!indexesList.length) {
		return [newIndexes, newArr];
	}
	newArr = indexesList.map(function (index) {
		return arr[index];
	});
	(0, _arrayIndexes.reindex)(newIndexes, newArr);
	return [newIndexes, newArr];
}

function fromJson(props, arr, json) {
	var indexes = props.indexes;
	var mutate = props.mutate;

	if (!json) {
		return [indexes, arr];
	}
	var jsonIndexes = json.indexes;
	var items = json.items;

	var newIndexes = (0, _arrayIndexes.indexesFromJson)(jsonIndexes);
	if (mutate) {
		arr.length = 0;
		arr.push.apply(arr, _toConsumableArray(items));
		return [newIndexes, arr];
	}
	return [newIndexes, items];
}