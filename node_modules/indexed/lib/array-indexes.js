'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.createIndexes = createIndexes;
exports.getIndexInIndexes = getIndexInIndexes;
exports.findIndexInIndexes = findIndexInIndexes;
exports.indexes = indexes;
exports.addIndex = addIndex;
exports.setIndexes = setIndexes;
exports.shiftIndexes = shiftIndexes;
exports.changeIndexes = changeIndexes;
exports.removeIndexes = removeIndexes;
exports.cloneIndexes = cloneIndexes;
exports.copyIndexes = copyIndexes;
exports.cleanIndexes = cleanIndexes;
exports.findIndex = findIndex;
exports.reindex = reindex;
exports.copyAndReindex = copyAndReindex;
exports.findIndexes = findIndexes;
exports.indexesToJson = indexesToJson;
exports.indexesFromJson = indexesFromJson;

var _utils = require('./utils');

var _constants = require('./constants');

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

function createIndexes(indexes) {
	if (indexes instanceof Map) {
		return indexes;
	}
	return (0, _utils.anythingToMap)(indexes, 2);
}

function getIndexInIndexes(indexes, name, predicate) {
	if (indexes.has(name) && indexes.get(name).has(predicate)) {
		return indexes.get(name).get(predicate);
	}
	return -1;
}

function findIndexInIndexes(indexes, predicateBlock, arr, thisArg) {
	if (!indexes) {
		return -1;
	}
	if (!Array.isArray(predicateBlock) || predicateBlock.length < 2) {
		return -1;
	}

	var _predicateBlock = _slicedToArray(predicateBlock, 2);

	var name = _predicateBlock[0];
	var predicate = _predicateBlock[1];

	if (/number|string/.test(typeof predicate === 'undefined' ? 'undefined' : _typeof(predicate))) {
		return getIndexInIndexes(indexes, name, predicate);
	}
	var fn = typeof predicate == 'function' ? predicate : predicate instanceof RegExp ? function (el) {
		return predicate.test(el);
	} : null;
	if (fn) {
		var map = indexes.get(name);
		var i = 0;
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = map[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var _step$value = _slicedToArray(_step.value, 2);

				var key = _step$value[0];
				var index = _step$value[1];

				var obj = arr[index];
				var correct = fn.call(thisArg, key, obj, map, arr, i);
				if (correct === _constants.BREAK) {
					return -1;
				}
				if (correct) {
					return index;
				}
				i++;
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	}
	return -1;
}

function indexes(indexes, arr, name) {
	if (name) {
		return indexes.has(name) ? indexes.get(name) : false;
	}
	return indexes;
}

function addIndex(indexes, arr, indexName, doReindex) {
	if (!indexes) {
		indexes = new Map();
	}
	indexes.set(indexName, new Map());
	if (doReindex) {
		return reindex(indexes, arr);
	}
	return indexes;
}

function setIndexes(indexes, obj, index) {
	if (!indexes || (0, _utils.isInvalidObject)(obj)) {
		return;
	}
	indexes.forEach(function (map, n) {
		if (n in obj) {
			var prop = obj[n];
			map.set(prop, index);
		}
	});
}

function shiftIndexes(indexes, ratio) {
	if (!indexes) {
		return;
	}
	indexes.forEach(function (map, n) {
		map.forEach(function (index, key) {
			map.set(key, index + ratio);
		});
	});
}

function changeIndexes(indexes, obj, newObj, index) {
	if (!indexes) {
		return;
	}
	indexes.forEach(function (map, n) {
		if (n in obj && (0, _utils.hasOwnProperty)(newObj, n)) {
			var prop = obj[n];
			var newProp = newObj[n];
			map.has(prop) && map.delete(prop) && map.set(newProp, index);
		}
	});
}

function removeIndexes(indexes, obj) {
	if (!indexes) {
		return;
	}
	indexes.forEach(function (map, n) {
		if (n in obj) {
			var prop = obj[n];
			map.has(prop) && map.delete(prop);
		}
	});
}

function cloneIndexes(indexes, shallow) {
	if (!indexes) {
		return;
	}
	var newIndexes = new Map();
	indexes.forEach(function (map, n) {
		newIndexes.set(n, shallow ? new Map() : (0, _utils.copyMap)(map, 1));
	});
	return newIndexes;
}

function copyIndexes(indexes) {
	if (!indexes) {
		return;
	}
	return cloneIndexes(indexes, true);
}

function cleanIndexes(indexes) {
	indexes.forEach(function (map, n) {
		indexes.set(n, new Map());
	});
}

function findIndex(props, arr, callbackOrPredicate, thisArg) {
	var indexes = props.indexes;

	if (typeof callbackOrPredicate == 'function') {
		return _constants.arrProto.findIndex.call(arr, callbackOrPredicate, thisArg);
	}
	if (indexes) {
		return findIndexInIndexes(indexes, callbackOrPredicate, arr, thisArg);
	}
	return -1;
}

function reindex(indexes, arr) {
	if (!indexes) {
		return;
	}
	var length = arr.length,
	    i = 0;
	cleanIndexes(indexes);
	while (i < length) {
		var value = arr[i];
		setIndexes(indexes, value, i++);
	}
	return indexes;
}

function copyAndReindex(indexes, arr) {
	reindex(copyIndexes(indexes), arr);
}

function findIndexes(_ref, arr, predicates, thisArg) {
	var indexes = _ref.indexes;
	var i = 0;var length = predicates.length;var max = arr.length;
	var results = [];
	if (typeof predicates == 'function') {
		while (i < max) {
			var value = arr[i];
			var answer = predicates.call(thisArg, value, i, arr);
			if (answer === _constants.BREAK) {
				return results;
			}
			if (answer) {
				results.push(i);
			}
			i++;
		}
		return results;
	}
	if (indexes) {
		var _ret = (function () {
			var _predicates = _slicedToArray(predicates, 2);

			var name = _predicates[0];
			var pre = _predicates[1];

			var map = indexes.get(name);
			var fn = typeof pre == 'function' ? pre : pre instanceof RegExp ? function (el) {
				return pre.test(el);
			} : null;
			if (fn) {
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = map[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var _step2$value = _slicedToArray(_step2.value, 2);

						var key = _step2$value[0];
						var index = _step2$value[1];

						var obj = arr[index];
						var answer = fn.call(thisArg, key, obj, map, arr, i);
						if (answer === _constants.BREAK) {
							return {
								v: results
							};
						}
						if (answer) {
							results.push(index);
						}
						i++;
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}

				return {
					v: results
				};
			}
			i = 1;
			var include = !!thisArg;
			while (i < length) {
				var predicate = predicates[i++];
				var answer = getIndexInIndexes(indexes, name, predicate);
				if (answer < 0) {
					include && results.push(-1);
				} else {
					results.push(answer);
				}
			}
		})();

		if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	}
	return results;
}

function indexesToJson(indexes) {
	var ret = {};
	indexes.forEach(function (map, name) {
		var list = {};
		map.forEach(function (value, prop) {
			list[prop] = value;
		});
		ret[name] = list;
	});
	return ret;
}

function indexesFromJson(json) {
	return (0, _utils.anythingToMap)(json, 2);
}